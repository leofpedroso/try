
import { ArchModel, ElementType } from "../types";

/**
 * Generates a Wavefront .OBJ 3D file content
 */
export const generateOBJ = (model: ArchModel): string => {
  let output = `# ModelAI LOD 500 Digital Twin Export\n# Unit: ${model.metadata.unit}\n`;
  output += `# Generated by ModelAI\n\n`;
  
  let vertexOffset = 1;
  const scale = 0.01; // Scale down from 0-1000 grid to usable units

  // Group by material to help external renderers
  const materials = new Set(model.elements.map(e => e.material || 'default'));
  
  materials.forEach(mat => {
    output += `g ${mat}_Group\n`; // Start a new group for this material
    output += `usemtl ${mat}\n`;  // Reference a material name (external tools can map this)

    model.elements.filter(e => (e.material || 'default') === mat).forEach((el, index) => {
        if (el.points.length < 3) return;

        output += `o ${el.label?.replace(/\s+/g, '_') || el.type}_${index}\n`;

        const h = el.height || 0.1;
        const elev = el.elevation || 0;
        
        const baseH = elev;
        const topH = elev + h;

        // 1. Generate Vertices
        // Bottom Face
        el.points.forEach(p => {
        output += `v ${p[0] * scale} ${baseH} ${p[1] * scale}\n`;
        });
        // Top Face
        el.points.forEach(p => {
        output += `v ${p[0] * scale} ${topH} ${p[1] * scale}\n`;
        });

        const numPoints = el.points.length;

        // 2. Generate Faces
        // Bottom Face (Reverse winding)
        output += `f`;
        for (let i = numPoints - 1; i >= 0; i--) {
        output += ` ${vertexOffset + i}`;
        }
        output += `\n`;

        // Top Face
        output += `f`;
        for (let i = 0; i < numPoints; i++) {
        output += ` ${vertexOffset + numPoints + i}`;
        }
        output += `\n`;

        // Side Faces
        for (let i = 0; i < numPoints; i++) {
        const next = (i + 1) % numPoints;
        // Quad: Bottom1 -> Bottom2 -> Top2 -> Top1
        const b1 = vertexOffset + i;
        const b2 = vertexOffset + next;
        const t1 = vertexOffset + numPoints + i;
        const t2 = vertexOffset + numPoints + next;
        output += `f ${b1} ${b2} ${t2} ${t1}\n`;
        }

        vertexOffset += numPoints * 2;
        output += `\n`;
    });
  });

  return output;
};

/**
 * Generates a simple DXF CAD file content
 */
export const generateDXF = (model: ArchModel): string => {
  let dxf = `0\nSECTION\n2\nHEADER\n0\nENDSEC\n0\nSECTION\n2\nENTITIES\n`;
  
  const scale = 1.0; 

  model.elements.forEach((el) => {
    const layer = (el.label || el.type).toUpperCase().replace(/\s+/g, '_');
    const color = el.type === ElementType.SOLID ? 7 : 3; // 7=White, 3=Green

    for (let i = 0; i < el.points.length; i++) {
      const p1 = el.points[i];
      const p2 = el.points[(i + 1) % el.points.length];

      dxf += `0\nLINE\n`;
      dxf += `8\n${layer}\n`; // Layer Name
      dxf += `62\n${color}\n`; // Color
      dxf += `10\n${p1[0] * scale}\n20\n${p1[1] * scale}\n30\n0.0\n`; // Start Point
      dxf += `11\n${p2[0] * scale}\n21\n${p2[1] * scale}\n31\n0.0\n`; // End Point
    }
  });

  dxf += `0\nENDSEC\n0\nEOF\n`;
  return dxf;
};

/**
 * Generates an SVG string (Vector CAD)
 */
export const generateSVG = (model: ArchModel): string => {
  const allPoints = model.elements.flatMap(e => e.points);
  const xs = allPoints.map(p => p[0]);
  const ys = allPoints.map(p => p[1]);
  const minX = Math.min(...xs) - 50;
  const minY = Math.min(...ys) - 50;
  const maxX = Math.max(...xs) + 50;
  const maxY = Math.max(...ys) + 50;
  const w = maxX - minX;
  const h = maxY - minY;

  let svg = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="${minX} ${minY} ${w} ${h}">\n`;
  svg += `<style> .solid { fill: #ccc; stroke: black; stroke-width: 2; } .void { fill: none; stroke: red; stroke-width: 2; } </style>\n`;

  // Sort by elevation so higher parts are drawn on top
  const sortedElements = [...model.elements].sort((a, b) => (a.elevation || 0) - (b.elevation || 0));

  sortedElements.forEach(el => {
    const pointsStr = el.points.map(p => `${p[0]},${p[1]}`).join(' ');
    // Opacity helps visualize overlap in 2D
    svg += `<polygon points="${pointsStr}" class="${el.type}" fill-opacity="0.8" />\n`;
  });

  svg += `</svg>`;
  return svg;
};

/**
 * Generates a basic IFC (Industry Foundation Classes) BIM file
 */
export const generateIFC = (model: ArchModel): string => {
  const uuid = () => '0' + Math.random().toString(36).substr(2, 9).toUpperCase() + Math.random().toString(36).substr(2, 9).toUpperCase();
  const date = new Date().toISOString().replace(/[-:]/g, '').split('.')[0];
  
  let ifc = `ISO-10303-21;
HEADER;
FILE_DESCRIPTION(('ViewDefinition [CoordinationView]'),'2;1');
FILE_NAME('ModelAI.ifc','${date}',('ModelAI User'),('ModelAI'),'Preprocessor version','ModelAI Generator','The authorising person');
FILE_SCHEMA(('IFC2X3'));
ENDSEC;
DATA;
#1=IFCORGANIZATION($,'ModelAI',$,$,$);
#2=IFCAPPLICATION(#1,'1.0','ModelAI','ModelAI_1.0');
#3=IFCPERSON($,'User','ModelAI',$,$,$,$,$);
#4=IFCPERSONANDORGANIZATION(#3,#1,$);
#5=IFCOWNERHISTORY(#4,#2,$,.ADDED.,$,$,$,1700000000);
#6=IFCDIRECTION((1.,0.,0.));
#7=IFCDIRECTION((0.,0.,1.));
#8=IFCCARTESIANPOINT((0.,0.,0.));
#9=IFCAXIS2PLACEMENT3D(#8,#7,#6);
#10=IFCDIRECTION((0.,1.,0.));
#11=IFCGEOMETRICREPRESENTATIONCONTEXT($,'Model',3,0.00001,#9,#10);
#12=IFCDIMENSIONALEXPONENTS(0,0,0,0,0,0,0);
#13=IFCSIUNIT(*,.LENGTHUNIT.,$,.METRE.);
#14=IFCSIUNIT(*,.AREAUNIT.,$,.SQUARE_METRE.);
#15=IFCSIUNIT(*,.VOLUMEUNIT.,$,.CUBIC_METRE.);
#16=IFCSIUNIT(*,.PLANEANGLEUNIT.,$,.RADIAN.);
#17=IFCUNITASSIGNMENT((#13,#14,#15,#16));
#18=IFCPROJECT('${uuid()}',#5,'ModelAI Project',$,$,$,$,(#11),#17);
#19=IFCSITE('${uuid()}',#5,'Default Site',$,$,#9,$,$,.ELEMENT.,(0,0,0),(0,0,0),0.,$,$);
#20=IFCRELAGGREGATES('${uuid()}',#5,$,$,#18,(#19));
#21=IFCBUILDING('${uuid()}',#5,'Default Building',$,$,#9,$,$,.ELEMENT.,$,$,$);
#22=IFCRELAGGREGATES('${uuid()}',#5,$,$,#19,(#21));
#23=IFCBUILDINGSTOREY('${uuid()}',#5,'Level 1',$,$,#9,$,$,.ELEMENT.,0.);
#24=IFCRELAGGREGATES('${uuid()}',#5,$,$,#21,(#23));
`;

  let idCounter = 100;
  const nextId = () => { idCounter++; return `#${idCounter}`; }
  
  const createPoint = (x: number, y: number, z: number) => {
      const id = nextId();
      ifc += `${id}=IFCCARTESIANPOINT((${x.toFixed(4)},${y.toFixed(4)},${z.toFixed(4)}));\n`;
      return id;
  }

  const scale = model.metadata.scale || 0.01;

  model.elements.forEach(el => {
      if (el.type === ElementType.SOLID) {
          const height = el.height || 2.5;
          const elevation = el.elevation || 0;
          const guid = uuid();
          
          const pointIds = el.points.map(p => createPoint(p[0]*scale, p[1]*scale, 0));
          const polyLineId = nextId();
          ifc += `${polyLineId}=IFCPOLYLINE((${pointIds.join(',')},${pointIds[0]}));\n`;

          const profileId = nextId();
          ifc += `${profileId}=IFCARBITRARYCLOSEDPROFILEDEF(.AREA.,$,${polyLineId});\n`;
          const dirId = nextId();
          ifc += `${dirId}=IFCDIRECTION((0.,0.,1.));\n`;
          const extrudeId = nextId();
          ifc += `${extrudeId}=IFCEXTRUDEDAREASOLID(${profileId},#9,${dirId},${height.toFixed(4)});\n`;

          const shapeRepId = nextId();
          ifc += `${shapeRepId}=IFCSHAPEREPRESENTATION(#11,'Body','SweptSolid',(${extrudeId}));\n`;
          const productDefId = nextId();
          ifc += `${productDefId}=IFCPRODUCTDEFINITIONSHAPE($,$,(${shapeRepId}));\n`;

          const placePointId = createPoint(0,0,elevation);
          const axis2PlacementId = nextId();
          ifc += `${axis2PlacementId}=IFCAXIS2PLACEMENT3D(${placePointId},$,$);\n`;
          const localPlacementId = nextId();
          ifc += `${localPlacementId}=IFCLOCALPLACEMENT($,${axis2PlacementId});\n`;

          const wallId = nextId();
          const label = el.label || 'Wall';
          const tag = el.twinData?.structuralClass ? `IFC${el.twinData.structuralClass.toUpperCase()}` : 'IFCWALLSTANDARDCASE';
          
          // Fallback to Wall if tag is invalid IFC
          const ifcType = tag.includes('FURNITURE') ? 'IFCFURNISHINGELEMENT' : 'IFCWALLSTANDARDCASE';

          ifc += `${wallId}=${ifcType}('${guid}',#5,'${label}',$,$,${localPlacementId},${productDefId},'${guid}');\n`;
          const relId = nextId();
          ifc += `${relId}=IFCRELCONTAINEDINSPATIALSTRUCTURE('${uuid()}',#5,$,$,(${wallId}),#23);\n`;
          
          // DIGITAL TWIN DATA INJECTION (Simplified Property Set)
          if (el.twinData) {
              const pSetId = nextId();
              const pName = nextId(); ifc += `${pName}=IFCPROPERTYSINGLEVALUE('Cost',$,IFCREAL(${el.twinData.costEstimate || 0}),$);\n`;
              const pCarbon = nextId(); ifc += `${pCarbon}=IFCPROPERTYSINGLEVALUE('Carbon',$,IFCREAL(${el.twinData.embodiedCarbon || 0}),$);\n`;
              const pThermal = nextId(); ifc += `${pThermal}=IFCPROPERTYSINGLEVALUE('Thermal',$,IFCREAL(${el.twinData.thermalTransmittance || 0}),$);\n`;
              
              ifc += `${pSetId}=IFCPROPERTYSET('${uuid()}',#5,'Pset_Environmental',$,(${pName},${pCarbon},${pThermal}));\n`;
              const relDefId = nextId();
              ifc += `${relDefId}=IFCRELDEFINESBYPROPERTIES('${uuid()}',#5,$,$,(${wallId}),${pSetId});\n`;
          }
      }
  });

  ifc += `ENDSEC;\nEND-ISO-10303-21;`;
  return ifc;
};
